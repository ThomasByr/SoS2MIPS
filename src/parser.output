State 65 conflicts: 2 shift/reduce
State 67 conflicts: 11 shift/reduce
State 106 conflicts: 1 shift/reduce
State 170 conflicts: 11 shift/reduce
State 187 conflicts: 11 shift/reduce
State 188 conflicts: 1 shift/reduce
State 200 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: instructions

    2 instructions: instructions ';' instruction
    3             | instruction
    4             | %empty

    5 instruction: ID '=' concat
    6            | ID '[' op_int ']' '=' concat
    7            | declare ID '[' integer ']'
    8            | IF testing THEN instructions maybe_else instructions FI
    9            | FOR ID DO instructions DONE
   10            | FOR ID IN ops DO instructions DONE
   11            | WHILE testing DO instructions DONE
   12            | UNTIL testing DO instructions DONE
   13            | CASE op IN cases ESAC
   14            | EKKO ops
   15            | READ ID
   16            | READ ID '[' op_int ']'
   17            | dfun
   18            | cfun
   19            | RETURN
   20            | RETURN op_int
   21            | EXIT
   22            | EXIT op_int

   23 maybe_else: ELIF testing THEN instructions maybe_else

   24 $@1: %empty

   25 maybe_else: ELSE $@1 instructions
   26           | %empty

   27 $@2: %empty

   28 cases: cases filter $@2 ')' instructions ';' ';'
   29      | filter ')' instructions ';' ';'

   30 filter: word
   31       | '"' string '"'
   32       | '\'' string '\''
   33       | filter '|' word
   34       | filter '|' '"' string '"'
   35       | filter '|' '\'' string '\''
   36       | '*'

   37 ops: ops op
   38    | op
   39    | '$' '{' ID '[' '*' ']' '}'

   40 concat: concat op
   41       | op

   42 testing: test test_expr

   43 test_expr: test_expr or test_expr2
   44          | test_expr2

   45 test_expr2: test_expr2 and test_expr3
   46           | test_expr3

   47 test_expr3: '(' test_expr ')'
   48           | '!' '(' test_expr ')'
   49           | test_instr
   50           | '!' test_instr

   51 test_instr: concat eq concat
   52           | concat neq concat
   53           | operator1 concat
   54           | op operator2 op

   55 op: '$' '{' ID '}'
   56   | '$' '{' ID '[' op_int ']' '}'
   57   | '$' integer
   58   | '$' '*'
   59   | '$' '?'
   60   | string
   61   | '$' '(' expr sum_int ')'
   62   | '$' '(' cfun ')'
   63   | integer

   64 operator1: nnull
   65          | null

   66 operator2: eq
   67          | neq
   68          | gt
   69          | ge
   70          | lt
   71          | le

   72 sum_int: sum_int plus_minus prod_int
   73        | prod_int

   74 prod_int: prod_int mult_div_mod op_int
   75         | op_int

   76 op_int: '$' '{' ID '}'
   77       | '$' '{' ID '[' op_int ']' '}'
   78       | '$' integer
   79       | plus_minus '$' '{' ID '}'
   80       | plus_minus '$' '{' ID '[' op_int ']' '}'
   81       | plus_minus '$' integer
   82       | integer
   83       | plus_minus integer
   84       | '(' sum_int ')'

   85 plus_minus: '+'
   86           | '-'

   87 mult_div_mod: '*'
   88             | '/'
   89             | '%'

   90 dfun: ID '(' ')' '{' declarations instructions '}'

   91 declarations: declarations local ID '=' concat ';'
   92             | %empty

   93 cfun: ID ops
   94     | ID


Terminals, with rules where they appear

    $end (0) 0
    '!' (33) 48 50
    '"' (34) 31 34
    '$' (36) 39 55 56 57 58 59 61 62 76 77 78 79 80 81
    '%' (37) 89
    '\'' (39) 32 35
    '(' (40) 47 48 61 62 84 90
    ')' (41) 28 29 47 48 61 62 84 90
    '*' (42) 36 39 58 87
    '+' (43) 85
    '-' (45) 86
    '/' (47) 88
    ';' (59) 2 28 29 91
    '=' (61) 5 6 91
    '?' (63) 59
    '[' (91) 6 7 16 39 56 77 80
    ']' (93) 6 7 16 39 56 77 80
    '{' (123) 39 55 56 76 77 79 80 90
    '|' (124) 33 34 35
    '}' (125) 39 55 56 76 77 79 80 90
    error (256)
    ID <id> (258) 5 6 7 9 10 15 16 39 55 56 76 77 79 80 90 91 93 94
    integer <integer_t> (259) 7 57 63 78 81 82 83
    declare (260) 7
    IF (261) 8
    THEN (262) 8 23
    ELIF (263) 23
    ELSE (264) 25
    FI (265) 8
    FOR (266) 9 10
    DO (267) 9 10 11 12
    IN (268) 10 13
    DONE (269) 9 10 11 12
    WHILE (270) 11
    UNTIL (271) 12
    CASE (272) 13
    ESAC (273) 13
    EKKO (274) 14
    READ (275) 15 16
    RETURN (276) 19 20
    EXIT (277) 21 22
    word <string> (278) 30 33
    string <string> (279) 31 32 34 35 60
    test (280) 42
    or (281) 43
    and (282) 45
    eq (283) 51 66
    neq (284) 52 67
    gt (285) 68
    ge (286) 69
    lt (287) 70
    le (288) 71
    null (289) 65
    nnull (290) 64
    expr (291) 61
    local (292) 91


Nonterminals, with rules where they appear

    $accept (57)
        on left: 0
    program <quad> (58)
        on left: 1
        on right: 0
    instructions <quad> (59)
        on left: 2 3 4
        on right: 1 2 8 9 10 11 12 23 25 28 29 90
    instruction <quad> (60)
        on left: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
        on right: 2 3
    maybe_else <quad> (61)
        on left: 23 25 26
        on right: 8 23
    $@1 (62)
        on left: 24
        on right: 25
    cases <quad> (63)
        on left: 28 29
        on right: 13 28
    $@2 (64)
        on left: 27
        on right: 28
    filter <filter_t> (65)
        on left: 30 31 32 33 34 35 36
        on right: 28 29 33 34 35
    ops <quad> (66)
        on left: 37 38 39
        on right: 10 14 37 93
    concat <quad> (67)
        on left: 40 41
        on right: 5 6 40 51 52 53 91
    testing <quad> (68)
        on left: 42
        on right: 8 11 12 23
    test_expr <quad> (69)
        on left: 43 44
        on right: 42 43 47 48
    test_expr2 <quad> (70)
        on left: 45 46
        on right: 43 44 45
    test_expr3 <quad> (71)
        on left: 47 48 49 50
        on right: 45 46
    test_instr <quad> (72)
        on left: 51 52 53 54
        on right: 49 50
    op <quad> (73)
        on left: 55 56 57 58 59 60 61 62 63
        on right: 13 37 38 40 41 54
    operator1 <integer_t> (74)
        on left: 64 65
        on right: 53
    operator2 <integer_t> (75)
        on left: 66 67 68 69 70 71
        on right: 54
    sum_int <quad> (76)
        on left: 72 73
        on right: 61 72 84
    prod_int <quad> (77)
        on left: 74 75
        on right: 72 73 74
    op_int <quad> (78)
        on left: 76 77 78 79 80 81 82 83 84
        on right: 6 16 20 22 56 74 75 77 80
    plus_minus <integer_t> (79)
        on left: 85 86
        on right: 72 79 80 81 83
    mult_div_mod <integer_t> (80)
        on left: 87 88 89
        on right: 74
    dfun <quad> (81)
        on left: 90
        on right: 17
    declarations <quad> (82)
        on left: 91 92
        on right: 90 91
    cfun <quad> (83)
        on left: 93 94
        on right: 18 62


State 0

    0 $accept: . program $end

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    program       go to state 12
    instructions  go to state 13
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 1

    5 instruction: ID . '=' concat
    6            | ID . '[' op_int ']' '=' concat
   90 dfun: ID . '(' ')' '{' declarations instructions '}'
   93 cfun: ID . ops
   94     | ID .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '='      shift, and go to state 19
    '['      shift, and go to state 20
    '$'      shift, and go to state 21
    '('      shift, and go to state 22

    $default  reduce using rule 94 (cfun)

    ops  go to state 23
    op   go to state 24


State 2

    7 instruction: declare . ID '[' integer ']'

    ID  shift, and go to state 25


State 3

    8 instruction: IF . testing THEN instructions maybe_else instructions FI

    test  shift, and go to state 26

    testing  go to state 27


State 4

    9 instruction: FOR . ID DO instructions DONE
   10            | FOR . ID IN ops DO instructions DONE

    ID  shift, and go to state 28


State 5

   11 instruction: WHILE . testing DO instructions DONE

    test  shift, and go to state 26

    testing  go to state 29


State 6

   12 instruction: UNTIL . testing DO instructions DONE

    test  shift, and go to state 26

    testing  go to state 30


State 7

   13 instruction: CASE . op IN cases ESAC

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    op  go to state 32


State 8

   14 instruction: EKKO . ops

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 21

    ops  go to state 33
    op   go to state 24


State 9

   15 instruction: READ . ID
   16            | READ . ID '[' op_int ']'

    ID  shift, and go to state 34


State 10

   19 instruction: RETURN .
   20            | RETURN . op_int

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    $default  reduce using rule 19 (instruction)

    op_int      go to state 40
    plus_minus  go to state 41


State 11

   21 instruction: EXIT .
   22            | EXIT . op_int

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    $default  reduce using rule 21 (instruction)

    op_int      go to state 42
    plus_minus  go to state 41


State 12

    0 $accept: program . $end

    $end  shift, and go to state 43


State 13

    1 program: instructions .
    2 instructions: instructions . ';' instruction

    ';'  shift, and go to state 44

    $default  reduce using rule 1 (program)


State 14

    3 instructions: instruction .

    $default  reduce using rule 3 (instructions)


State 15

   17 instruction: dfun .

    $default  reduce using rule 17 (instruction)


State 16

   18 instruction: cfun .

    $default  reduce using rule 18 (instruction)


State 17

   63 op: integer .

    $default  reduce using rule 63 (op)


State 18

   60 op: string .

    $default  reduce using rule 60 (op)


State 19

    5 instruction: ID '=' . concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 45
    op      go to state 46


State 20

    6 instruction: ID '[' . op_int ']' '=' concat

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 47
    plus_minus  go to state 41


State 21

   39 ops: '$' . '{' ID '[' '*' ']' '}'
   55 op: '$' . '{' ID '}'
   56   | '$' . '{' ID '[' op_int ']' '}'
   57   | '$' . integer
   58   | '$' . '*'
   59   | '$' . '?'
   61   | '$' . '(' expr sum_int ')'
   62   | '$' . '(' cfun ')'

    integer  shift, and go to state 48
    '*'      shift, and go to state 49
    '{'      shift, and go to state 50
    '('      shift, and go to state 51
    '?'      shift, and go to state 52


State 22

   90 dfun: ID '(' . ')' '{' declarations instructions '}'

    ')'  shift, and go to state 53


State 23

   37 ops: ops . op
   93 cfun: ID ops .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 93 (cfun)

    op  go to state 54


State 24

   38 ops: op .

    $default  reduce using rule 38 (ops)


State 25

    7 instruction: declare ID . '[' integer ']'

    '['  shift, and go to state 55


State 26

   42 testing: test . test_expr

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 58
    '!'      shift, and go to state 59

    concat      go to state 60
    test_expr   go to state 61
    test_expr2  go to state 62
    test_expr3  go to state 63
    test_instr  go to state 64
    op          go to state 65
    operator1   go to state 66


State 27

    8 instruction: IF testing . THEN instructions maybe_else instructions FI

    THEN  shift, and go to state 67


State 28

    9 instruction: FOR ID . DO instructions DONE
   10            | FOR ID . IN ops DO instructions DONE

    DO  shift, and go to state 68
    IN  shift, and go to state 69


State 29

   11 instruction: WHILE testing . DO instructions DONE

    DO  shift, and go to state 70


State 30

   12 instruction: UNTIL testing . DO instructions DONE

    DO  shift, and go to state 71


State 31

   55 op: '$' . '{' ID '}'
   56   | '$' . '{' ID '[' op_int ']' '}'
   57   | '$' . integer
   58   | '$' . '*'
   59   | '$' . '?'
   61   | '$' . '(' expr sum_int ')'
   62   | '$' . '(' cfun ')'

    integer  shift, and go to state 48
    '*'      shift, and go to state 49
    '{'      shift, and go to state 72
    '('      shift, and go to state 51
    '?'      shift, and go to state 52


State 32

   13 instruction: CASE op . IN cases ESAC

    IN  shift, and go to state 73


State 33

   14 instruction: EKKO ops .
   37 ops: ops . op

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 14 (instruction)

    op  go to state 54


State 34

   15 instruction: READ ID .
   16            | READ ID . '[' op_int ']'

    '['  shift, and go to state 74

    $default  reduce using rule 15 (instruction)


State 35

   82 op_int: integer .

    $default  reduce using rule 82 (op_int)


State 36

   85 plus_minus: '+' .

    $default  reduce using rule 85 (plus_minus)


State 37

   86 plus_minus: '-' .

    $default  reduce using rule 86 (plus_minus)


State 38

   76 op_int: '$' . '{' ID '}'
   77       | '$' . '{' ID '[' op_int ']' '}'
   78       | '$' . integer

    integer  shift, and go to state 75
    '{'      shift, and go to state 76


State 39

   84 op_int: '(' . sum_int ')'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    sum_int     go to state 77
    prod_int    go to state 78
    op_int      go to state 79
    plus_minus  go to state 41


State 40

   20 instruction: RETURN op_int .

    $default  reduce using rule 20 (instruction)


State 41

   79 op_int: plus_minus . '$' '{' ID '}'
   80       | plus_minus . '$' '{' ID '[' op_int ']' '}'
   81       | plus_minus . '$' integer
   83       | plus_minus . integer

    integer  shift, and go to state 80
    '$'      shift, and go to state 81


State 42

   22 instruction: EXIT op_int .

    $default  reduce using rule 22 (instruction)


State 43

    0 $accept: program $end .

    $default  accept


State 44

    2 instructions: instructions ';' . instruction

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    instruction  go to state 82
    dfun         go to state 15
    cfun         go to state 16


State 45

    5 instruction: ID '=' concat .
   40 concat: concat . op

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 5 (instruction)

    op  go to state 83


State 46

   41 concat: op .

    $default  reduce using rule 41 (concat)


State 47

    6 instruction: ID '[' op_int . ']' '=' concat

    ']'  shift, and go to state 84


State 48

   57 op: '$' integer .

    $default  reduce using rule 57 (op)


State 49

   58 op: '$' '*' .

    $default  reduce using rule 58 (op)


State 50

   39 ops: '$' '{' . ID '[' '*' ']' '}'
   55 op: '$' '{' . ID '}'
   56   | '$' '{' . ID '[' op_int ']' '}'

    ID  shift, and go to state 85


State 51

   61 op: '$' '(' . expr sum_int ')'
   62   | '$' '(' . cfun ')'

    ID    shift, and go to state 86
    expr  shift, and go to state 87

    cfun  go to state 88


State 52

   59 op: '$' '?' .

    $default  reduce using rule 59 (op)


State 53

   90 dfun: ID '(' ')' . '{' declarations instructions '}'

    '{'  shift, and go to state 89


State 54

   37 ops: ops op .

    $default  reduce using rule 37 (ops)


State 55

    7 instruction: declare ID '[' . integer ']'

    integer  shift, and go to state 90


State 56

   65 operator1: null .

    $default  reduce using rule 65 (operator1)


State 57

   64 operator1: nnull .

    $default  reduce using rule 64 (operator1)


State 58

   47 test_expr3: '(' . test_expr ')'

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 58
    '!'      shift, and go to state 59

    concat      go to state 60
    test_expr   go to state 91
    test_expr2  go to state 62
    test_expr3  go to state 63
    test_instr  go to state 64
    op          go to state 65
    operator1   go to state 66


State 59

   48 test_expr3: '!' . '(' test_expr ')'
   50           | '!' . test_instr

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 92

    concat      go to state 60
    test_instr  go to state 93
    op          go to state 65
    operator1   go to state 66


State 60

   40 concat: concat . op
   51 test_instr: concat . eq concat
   52           | concat . neq concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    eq       shift, and go to state 94
    neq      shift, and go to state 95
    '$'      shift, and go to state 31

    op  go to state 83


State 61

   42 testing: test test_expr .
   43 test_expr: test_expr . or test_expr2

    or  shift, and go to state 96

    $default  reduce using rule 42 (testing)


State 62

   44 test_expr: test_expr2 .
   45 test_expr2: test_expr2 . and test_expr3

    and  shift, and go to state 97

    $default  reduce using rule 44 (test_expr)


State 63

   46 test_expr2: test_expr3 .

    $default  reduce using rule 46 (test_expr2)


State 64

   49 test_expr3: test_instr .

    $default  reduce using rule 49 (test_expr3)


State 65

   41 concat: op .
   54 test_instr: op . operator2 op

    eq   shift, and go to state 98
    neq  shift, and go to state 99
    gt   shift, and go to state 100
    ge   shift, and go to state 101
    lt   shift, and go to state 102
    le   shift, and go to state 103

    eq        [reduce using rule 41 (concat)]
    neq       [reduce using rule 41 (concat)]
    $default  reduce using rule 41 (concat)

    operator2  go to state 104


State 66

   53 test_instr: operator1 . concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 105
    op      go to state 46


State 67

    8 instruction: IF testing THEN . instructions maybe_else instructions FI

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    ID        [reduce using rule 4 (instructions)]
    declare   [reduce using rule 4 (instructions)]
    IF        [reduce using rule 4 (instructions)]
    FOR       [reduce using rule 4 (instructions)]
    WHILE     [reduce using rule 4 (instructions)]
    UNTIL     [reduce using rule 4 (instructions)]
    CASE      [reduce using rule 4 (instructions)]
    EKKO      [reduce using rule 4 (instructions)]
    READ      [reduce using rule 4 (instructions)]
    RETURN    [reduce using rule 4 (instructions)]
    EXIT      [reduce using rule 4 (instructions)]
    $default  reduce using rule 4 (instructions)

    instructions  go to state 106
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 68

    9 instruction: FOR ID DO . instructions DONE

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 107
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 69

   10 instruction: FOR ID IN . ops DO instructions DONE

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 21

    ops  go to state 108
    op   go to state 24


State 70

   11 instruction: WHILE testing DO . instructions DONE

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 109
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 71

   12 instruction: UNTIL testing DO . instructions DONE

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 110
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 72

   55 op: '$' '{' . ID '}'
   56   | '$' '{' . ID '[' op_int ']' '}'

    ID  shift, and go to state 111


State 73

   13 instruction: CASE op IN . cases ESAC

    word  shift, and go to state 112
    '*'   shift, and go to state 113
    '"'   shift, and go to state 114
    '\''  shift, and go to state 115

    cases   go to state 116
    filter  go to state 117


State 74

   16 instruction: READ ID '[' . op_int ']'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 118
    plus_minus  go to state 41


State 75

   78 op_int: '$' integer .

    $default  reduce using rule 78 (op_int)


State 76

   76 op_int: '$' '{' . ID '}'
   77       | '$' '{' . ID '[' op_int ']' '}'

    ID  shift, and go to state 119


State 77

   72 sum_int: sum_int . plus_minus prod_int
   84 op_int: '(' sum_int . ')'

    '+'  shift, and go to state 36
    '-'  shift, and go to state 37
    ')'  shift, and go to state 120

    plus_minus  go to state 121


State 78

   73 sum_int: prod_int .
   74 prod_int: prod_int . mult_div_mod op_int

    '*'  shift, and go to state 122
    '/'  shift, and go to state 123
    '%'  shift, and go to state 124

    $default  reduce using rule 73 (sum_int)

    mult_div_mod  go to state 125


State 79

   75 prod_int: op_int .

    $default  reduce using rule 75 (prod_int)


State 80

   83 op_int: plus_minus integer .

    $default  reduce using rule 83 (op_int)


State 81

   79 op_int: plus_minus '$' . '{' ID '}'
   80       | plus_minus '$' . '{' ID '[' op_int ']' '}'
   81       | plus_minus '$' . integer

    integer  shift, and go to state 126
    '{'      shift, and go to state 127


State 82

    2 instructions: instructions ';' instruction .

    $default  reduce using rule 2 (instructions)


State 83

   40 concat: concat op .

    $default  reduce using rule 40 (concat)


State 84

    6 instruction: ID '[' op_int ']' . '=' concat

    '='  shift, and go to state 128


State 85

   39 ops: '$' '{' ID . '[' '*' ']' '}'
   55 op: '$' '{' ID . '}'
   56   | '$' '{' ID . '[' op_int ']' '}'

    '['  shift, and go to state 129
    '}'  shift, and go to state 130


State 86

   93 cfun: ID . ops
   94     | ID .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 21

    $default  reduce using rule 94 (cfun)

    ops  go to state 23
    op   go to state 24


State 87

   61 op: '$' '(' expr . sum_int ')'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    sum_int     go to state 131
    prod_int    go to state 78
    op_int      go to state 79
    plus_minus  go to state 41


State 88

   62 op: '$' '(' cfun . ')'

    ')'  shift, and go to state 132


State 89

   90 dfun: ID '(' ')' '{' . declarations instructions '}'

    $default  reduce using rule 92 (declarations)

    declarations  go to state 133


State 90

    7 instruction: declare ID '[' integer . ']'

    ']'  shift, and go to state 134


State 91

   43 test_expr: test_expr . or test_expr2
   47 test_expr3: '(' test_expr . ')'

    or   shift, and go to state 96
    ')'  shift, and go to state 135


State 92

   48 test_expr3: '!' '(' . test_expr ')'

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 58
    '!'      shift, and go to state 59

    concat      go to state 60
    test_expr   go to state 136
    test_expr2  go to state 62
    test_expr3  go to state 63
    test_instr  go to state 64
    op          go to state 65
    operator1   go to state 66


State 93

   50 test_expr3: '!' test_instr .

    $default  reduce using rule 50 (test_expr3)


State 94

   51 test_instr: concat eq . concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 137
    op      go to state 46


State 95

   52 test_instr: concat neq . concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 138
    op      go to state 46


State 96

   43 test_expr: test_expr or . test_expr2

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 58
    '!'      shift, and go to state 59

    concat      go to state 60
    test_expr2  go to state 139
    test_expr3  go to state 63
    test_instr  go to state 64
    op          go to state 65
    operator1   go to state 66


State 97

   45 test_expr2: test_expr2 and . test_expr3

    integer  shift, and go to state 17
    string   shift, and go to state 18
    null     shift, and go to state 56
    nnull    shift, and go to state 57
    '$'      shift, and go to state 31
    '('      shift, and go to state 58
    '!'      shift, and go to state 59

    concat      go to state 60
    test_expr3  go to state 140
    test_instr  go to state 64
    op          go to state 65
    operator1   go to state 66


State 98

   66 operator2: eq .

    $default  reduce using rule 66 (operator2)


State 99

   67 operator2: neq .

    $default  reduce using rule 67 (operator2)


State 100

   68 operator2: gt .

    $default  reduce using rule 68 (operator2)


State 101

   69 operator2: ge .

    $default  reduce using rule 69 (operator2)


State 102

   70 operator2: lt .

    $default  reduce using rule 70 (operator2)


State 103

   71 operator2: le .

    $default  reduce using rule 71 (operator2)


State 104

   54 test_instr: op operator2 . op

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    op  go to state 141


State 105

   40 concat: concat . op
   53 test_instr: operator1 concat .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 53 (test_instr)

    op  go to state 83


State 106

    2 instructions: instructions . ';' instruction
    8 instruction: IF testing THEN instructions . maybe_else instructions FI

    ELIF  shift, and go to state 142
    ELSE  shift, and go to state 143
    ';'   shift, and go to state 44

    ';'       [reduce using rule 26 (maybe_else)]
    $default  reduce using rule 26 (maybe_else)

    maybe_else  go to state 144


State 107

    2 instructions: instructions . ';' instruction
    9 instruction: FOR ID DO instructions . DONE

    DONE  shift, and go to state 145
    ';'   shift, and go to state 44


State 108

   10 instruction: FOR ID IN ops . DO instructions DONE
   37 ops: ops . op

    integer  shift, and go to state 17
    DO       shift, and go to state 146
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    op  go to state 54


State 109

    2 instructions: instructions . ';' instruction
   11 instruction: WHILE testing DO instructions . DONE

    DONE  shift, and go to state 147
    ';'   shift, and go to state 44


State 110

    2 instructions: instructions . ';' instruction
   12 instruction: UNTIL testing DO instructions . DONE

    DONE  shift, and go to state 148
    ';'   shift, and go to state 44


State 111

   55 op: '$' '{' ID . '}'
   56   | '$' '{' ID . '[' op_int ']' '}'

    '['  shift, and go to state 149
    '}'  shift, and go to state 130


State 112

   30 filter: word .

    $default  reduce using rule 30 (filter)


State 113

   36 filter: '*' .

    $default  reduce using rule 36 (filter)


State 114

   31 filter: '"' . string '"'

    string  shift, and go to state 150


State 115

   32 filter: '\'' . string '\''

    string  shift, and go to state 151


State 116

   13 instruction: CASE op IN cases . ESAC
   28 cases: cases . filter $@2 ')' instructions ';' ';'

    ESAC  shift, and go to state 152
    word  shift, and go to state 112
    '*'   shift, and go to state 113
    '"'   shift, and go to state 114
    '\''  shift, and go to state 115

    filter  go to state 153


State 117

   29 cases: filter . ')' instructions ';' ';'
   33 filter: filter . '|' word
   34       | filter . '|' '"' string '"'
   35       | filter . '|' '\'' string '\''

    ')'  shift, and go to state 154
    '|'  shift, and go to state 155


State 118

   16 instruction: READ ID '[' op_int . ']'

    ']'  shift, and go to state 156


State 119

   76 op_int: '$' '{' ID . '}'
   77       | '$' '{' ID . '[' op_int ']' '}'

    '['  shift, and go to state 157
    '}'  shift, and go to state 158


State 120

   84 op_int: '(' sum_int ')' .

    $default  reduce using rule 84 (op_int)


State 121

   72 sum_int: sum_int plus_minus . prod_int

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    prod_int    go to state 159
    op_int      go to state 79
    plus_minus  go to state 41


State 122

   87 mult_div_mod: '*' .

    $default  reduce using rule 87 (mult_div_mod)


State 123

   88 mult_div_mod: '/' .

    $default  reduce using rule 88 (mult_div_mod)


State 124

   89 mult_div_mod: '%' .

    $default  reduce using rule 89 (mult_div_mod)


State 125

   74 prod_int: prod_int mult_div_mod . op_int

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 160
    plus_minus  go to state 41


State 126

   81 op_int: plus_minus '$' integer .

    $default  reduce using rule 81 (op_int)


State 127

   79 op_int: plus_minus '$' '{' . ID '}'
   80       | plus_minus '$' '{' . ID '[' op_int ']' '}'

    ID  shift, and go to state 161


State 128

    6 instruction: ID '[' op_int ']' '=' . concat

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 162
    op      go to state 46


State 129

   39 ops: '$' '{' ID '[' . '*' ']' '}'
   56 op: '$' '{' ID '[' . op_int ']' '}'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '*'      shift, and go to state 163
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 164
    plus_minus  go to state 41


State 130

   55 op: '$' '{' ID '}' .

    $default  reduce using rule 55 (op)


State 131

   61 op: '$' '(' expr sum_int . ')'
   72 sum_int: sum_int . plus_minus prod_int

    '+'  shift, and go to state 36
    '-'  shift, and go to state 37
    ')'  shift, and go to state 165

    plus_minus  go to state 121


State 132

   62 op: '$' '(' cfun ')' .

    $default  reduce using rule 62 (op)


State 133

   90 dfun: ID '(' ')' '{' declarations . instructions '}'
   91 declarations: declarations . local ID '=' concat ';'

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11
    local    shift, and go to state 166

    $default  reduce using rule 4 (instructions)

    instructions  go to state 167
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 134

    7 instruction: declare ID '[' integer ']' .

    $default  reduce using rule 7 (instruction)


State 135

   47 test_expr3: '(' test_expr ')' .

    $default  reduce using rule 47 (test_expr3)


State 136

   43 test_expr: test_expr . or test_expr2
   48 test_expr3: '!' '(' test_expr . ')'

    or   shift, and go to state 96
    ')'  shift, and go to state 168


State 137

   40 concat: concat . op
   51 test_instr: concat eq concat .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 51 (test_instr)

    op  go to state 83


State 138

   40 concat: concat . op
   52 test_instr: concat neq concat .

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 52 (test_instr)

    op  go to state 83


State 139

   43 test_expr: test_expr or test_expr2 .
   45 test_expr2: test_expr2 . and test_expr3

    and  shift, and go to state 97

    $default  reduce using rule 43 (test_expr)


State 140

   45 test_expr2: test_expr2 and test_expr3 .

    $default  reduce using rule 45 (test_expr2)


State 141

   54 test_instr: op operator2 op .

    $default  reduce using rule 54 (test_instr)


State 142

   23 maybe_else: ELIF . testing THEN instructions maybe_else

    test  shift, and go to state 26

    testing  go to state 169


State 143

   25 maybe_else: ELSE . $@1 instructions

    $default  reduce using rule 24 ($@1)

    $@1  go to state 170


State 144

    8 instruction: IF testing THEN instructions maybe_else . instructions FI

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 171
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 145

    9 instruction: FOR ID DO instructions DONE .

    $default  reduce using rule 9 (instruction)


State 146

   10 instruction: FOR ID IN ops DO . instructions DONE

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 172
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 147

   11 instruction: WHILE testing DO instructions DONE .

    $default  reduce using rule 11 (instruction)


State 148

   12 instruction: UNTIL testing DO instructions DONE .

    $default  reduce using rule 12 (instruction)


State 149

   56 op: '$' '{' ID '[' . op_int ']' '}'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 164
    plus_minus  go to state 41


State 150

   31 filter: '"' string . '"'

    '"'  shift, and go to state 173


State 151

   32 filter: '\'' string . '\''

    '\''  shift, and go to state 174


State 152

   13 instruction: CASE op IN cases ESAC .

    $default  reduce using rule 13 (instruction)


State 153

   28 cases: cases filter . $@2 ')' instructions ';' ';'
   33 filter: filter . '|' word
   34       | filter . '|' '"' string '"'
   35       | filter . '|' '\'' string '\''

    '|'  shift, and go to state 155

    $default  reduce using rule 27 ($@2)

    $@2  go to state 175


State 154

   29 cases: filter ')' . instructions ';' ';'

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 176
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 155

   33 filter: filter '|' . word
   34       | filter '|' . '"' string '"'
   35       | filter '|' . '\'' string '\''

    word  shift, and go to state 177
    '"'   shift, and go to state 178
    '\''  shift, and go to state 179


State 156

   16 instruction: READ ID '[' op_int ']' .

    $default  reduce using rule 16 (instruction)


State 157

   77 op_int: '$' '{' ID '[' . op_int ']' '}'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 180
    plus_minus  go to state 41


State 158

   76 op_int: '$' '{' ID '}' .

    $default  reduce using rule 76 (op_int)


State 159

   72 sum_int: sum_int plus_minus prod_int .
   74 prod_int: prod_int . mult_div_mod op_int

    '*'  shift, and go to state 122
    '/'  shift, and go to state 123
    '%'  shift, and go to state 124

    $default  reduce using rule 72 (sum_int)

    mult_div_mod  go to state 125


State 160

   74 prod_int: prod_int mult_div_mod op_int .

    $default  reduce using rule 74 (prod_int)


State 161

   79 op_int: plus_minus '$' '{' ID . '}'
   80       | plus_minus '$' '{' ID . '[' op_int ']' '}'

    '['  shift, and go to state 181
    '}'  shift, and go to state 182


State 162

    6 instruction: ID '[' op_int ']' '=' concat .
   40 concat: concat . op

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    $default  reduce using rule 6 (instruction)

    op  go to state 83


State 163

   39 ops: '$' '{' ID '[' '*' . ']' '}'

    ']'  shift, and go to state 183


State 164

   56 op: '$' '{' ID '[' op_int . ']' '}'

    ']'  shift, and go to state 184


State 165

   61 op: '$' '(' expr sum_int ')' .

    $default  reduce using rule 61 (op)


State 166

   91 declarations: declarations local . ID '=' concat ';'

    ID  shift, and go to state 185


State 167

    2 instructions: instructions . ';' instruction
   90 dfun: ID '(' ')' '{' declarations instructions . '}'

    ';'  shift, and go to state 44
    '}'  shift, and go to state 186


State 168

   48 test_expr3: '!' '(' test_expr ')' .

    $default  reduce using rule 48 (test_expr3)


State 169

   23 maybe_else: ELIF testing . THEN instructions maybe_else

    THEN  shift, and go to state 187


State 170

   25 maybe_else: ELSE $@1 . instructions

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    ID        [reduce using rule 4 (instructions)]
    declare   [reduce using rule 4 (instructions)]
    IF        [reduce using rule 4 (instructions)]
    FOR       [reduce using rule 4 (instructions)]
    WHILE     [reduce using rule 4 (instructions)]
    UNTIL     [reduce using rule 4 (instructions)]
    CASE      [reduce using rule 4 (instructions)]
    EKKO      [reduce using rule 4 (instructions)]
    READ      [reduce using rule 4 (instructions)]
    RETURN    [reduce using rule 4 (instructions)]
    EXIT      [reduce using rule 4 (instructions)]
    $default  reduce using rule 4 (instructions)

    instructions  go to state 188
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 171

    2 instructions: instructions . ';' instruction
    8 instruction: IF testing THEN instructions maybe_else instructions . FI

    FI   shift, and go to state 189
    ';'  shift, and go to state 44


State 172

    2 instructions: instructions . ';' instruction
   10 instruction: FOR ID IN ops DO instructions . DONE

    DONE  shift, and go to state 190
    ';'   shift, and go to state 44


State 173

   31 filter: '"' string '"' .

    $default  reduce using rule 31 (filter)


State 174

   32 filter: '\'' string '\'' .

    $default  reduce using rule 32 (filter)


State 175

   28 cases: cases filter $@2 . ')' instructions ';' ';'

    ')'  shift, and go to state 191


State 176

    2 instructions: instructions . ';' instruction
   29 cases: filter ')' instructions . ';' ';'

    ';'  shift, and go to state 192


State 177

   33 filter: filter '|' word .

    $default  reduce using rule 33 (filter)


State 178

   34 filter: filter '|' '"' . string '"'

    string  shift, and go to state 193


State 179

   35 filter: filter '|' '\'' . string '\''

    string  shift, and go to state 194


State 180

   77 op_int: '$' '{' ID '[' op_int . ']' '}'

    ']'  shift, and go to state 195


State 181

   80 op_int: plus_minus '$' '{' ID '[' . op_int ']' '}'

    integer  shift, and go to state 35
    '+'      shift, and go to state 36
    '-'      shift, and go to state 37
    '$'      shift, and go to state 38
    '('      shift, and go to state 39

    op_int      go to state 196
    plus_minus  go to state 41


State 182

   79 op_int: plus_minus '$' '{' ID '}' .

    $default  reduce using rule 79 (op_int)


State 183

   39 ops: '$' '{' ID '[' '*' ']' . '}'

    '}'  shift, and go to state 197


State 184

   56 op: '$' '{' ID '[' op_int ']' . '}'

    '}'  shift, and go to state 198


State 185

   91 declarations: declarations local ID . '=' concat ';'

    '='  shift, and go to state 199


State 186

   90 dfun: ID '(' ')' '{' declarations instructions '}' .

    $default  reduce using rule 90 (dfun)


State 187

   23 maybe_else: ELIF testing THEN . instructions maybe_else

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    ID        [reduce using rule 4 (instructions)]
    declare   [reduce using rule 4 (instructions)]
    IF        [reduce using rule 4 (instructions)]
    FOR       [reduce using rule 4 (instructions)]
    WHILE     [reduce using rule 4 (instructions)]
    UNTIL     [reduce using rule 4 (instructions)]
    CASE      [reduce using rule 4 (instructions)]
    EKKO      [reduce using rule 4 (instructions)]
    READ      [reduce using rule 4 (instructions)]
    RETURN    [reduce using rule 4 (instructions)]
    EXIT      [reduce using rule 4 (instructions)]
    $default  reduce using rule 4 (instructions)

    instructions  go to state 200
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 188

    2 instructions: instructions . ';' instruction
   25 maybe_else: ELSE $@1 instructions .

    ';'  shift, and go to state 44

    ';'       [reduce using rule 25 (maybe_else)]
    $default  reduce using rule 25 (maybe_else)


State 189

    8 instruction: IF testing THEN instructions maybe_else instructions FI .

    $default  reduce using rule 8 (instruction)


State 190

   10 instruction: FOR ID IN ops DO instructions DONE .

    $default  reduce using rule 10 (instruction)


State 191

   28 cases: cases filter $@2 ')' . instructions ';' ';'

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11

    $default  reduce using rule 4 (instructions)

    instructions  go to state 201
    instruction   go to state 14
    dfun          go to state 15
    cfun          go to state 16


State 192

    2 instructions: instructions ';' . instruction
   29 cases: filter ')' instructions ';' . ';'

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11
    ';'      shift, and go to state 202

    instruction  go to state 82
    dfun         go to state 15
    cfun         go to state 16


State 193

   34 filter: filter '|' '"' string . '"'

    '"'  shift, and go to state 203


State 194

   35 filter: filter '|' '\'' string . '\''

    '\''  shift, and go to state 204


State 195

   77 op_int: '$' '{' ID '[' op_int ']' . '}'

    '}'  shift, and go to state 205


State 196

   80 op_int: plus_minus '$' '{' ID '[' op_int . ']' '}'

    ']'  shift, and go to state 206


State 197

   39 ops: '$' '{' ID '[' '*' ']' '}' .

    $default  reduce using rule 39 (ops)


State 198

   56 op: '$' '{' ID '[' op_int ']' '}' .

    $default  reduce using rule 56 (op)


State 199

   91 declarations: declarations local ID '=' . concat ';'

    integer  shift, and go to state 17
    string   shift, and go to state 18
    '$'      shift, and go to state 31

    concat  go to state 207
    op      go to state 46


State 200

    2 instructions: instructions . ';' instruction
   23 maybe_else: ELIF testing THEN instructions . maybe_else

    ELIF  shift, and go to state 142
    ELSE  shift, and go to state 143
    ';'   shift, and go to state 44

    ';'       [reduce using rule 26 (maybe_else)]
    $default  reduce using rule 26 (maybe_else)

    maybe_else  go to state 208


State 201

    2 instructions: instructions . ';' instruction
   28 cases: cases filter $@2 ')' instructions . ';' ';'

    ';'  shift, and go to state 209


State 202

   29 cases: filter ')' instructions ';' ';' .

    $default  reduce using rule 29 (cases)


State 203

   34 filter: filter '|' '"' string '"' .

    $default  reduce using rule 34 (filter)


State 204

   35 filter: filter '|' '\'' string '\'' .

    $default  reduce using rule 35 (filter)


State 205

   77 op_int: '$' '{' ID '[' op_int ']' '}' .

    $default  reduce using rule 77 (op_int)


State 206

   80 op_int: plus_minus '$' '{' ID '[' op_int ']' . '}'

    '}'  shift, and go to state 210


State 207

   40 concat: concat . op
   91 declarations: declarations local ID '=' concat . ';'

    integer  shift, and go to state 17
    string   shift, and go to state 18
    ';'      shift, and go to state 211
    '$'      shift, and go to state 31

    op  go to state 83


State 208

   23 maybe_else: ELIF testing THEN instructions maybe_else .

    $default  reduce using rule 23 (maybe_else)


State 209

    2 instructions: instructions ';' . instruction
   28 cases: cases filter $@2 ')' instructions ';' . ';'

    ID       shift, and go to state 1
    declare  shift, and go to state 2
    IF       shift, and go to state 3
    FOR      shift, and go to state 4
    WHILE    shift, and go to state 5
    UNTIL    shift, and go to state 6
    CASE     shift, and go to state 7
    EKKO     shift, and go to state 8
    READ     shift, and go to state 9
    RETURN   shift, and go to state 10
    EXIT     shift, and go to state 11
    ';'      shift, and go to state 212

    instruction  go to state 82
    dfun         go to state 15
    cfun         go to state 16


State 210

   80 op_int: plus_minus '$' '{' ID '[' op_int ']' '}' .

    $default  reduce using rule 80 (op_int)


State 211

   91 declarations: declarations local ID '=' concat ';' .

    $default  reduce using rule 91 (declarations)


State 212

   28 cases: cases filter $@2 ')' instructions ';' ';' .

    $default  reduce using rule 28 (cases)
